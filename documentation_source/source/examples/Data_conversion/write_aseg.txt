def write_aseg(self, filename):
        """Export tabular data to an ASEG formatted data file

        Parameters
        ----------
        filename : str
            Path to output aseg file

        """
        from ...utilities.xarray_utilities import unreconcile_xarray, write_dfn, get_nulls_formats_xarr
        
        new_dat_filename, new_dfn_filename = filename, filename.replace(".dat", ".dfn")

        tmpds = deepcopy(self.xarray)
        tmpds = unreconcile_xarray(tmpds)

        null_values, format_strings = get_nulls_formats_xarr(tmpds)
        write_dfn(tmpds, new_dfn_filename, null_values, format_strings)

        format_fields = ", ".join([val for key,val in format_strings.items()])
        writer = fortranformat.FortranRecordWriter("(" + format_fields + ")")
        
        with open(new_dat_filename, "w") as new_dat:
            for idx, series in tmpds.to_dataframe().iterrows():
                #series_filled = series.fillna(null_values[series.name])
                #line = writer.write(series_filled).replace("\n", "")
                line = writer.write(series).replace("\n", "")
                new_dat.write(line + "\n")


NEW FILE XARRAY_UTILITIES

def get_nulls_formats_xarr(xarr):
    """
    Get formats and null values from xarray dataset.

    Parameters
    ----------
    xarr : xarray dataset
    
    Returns
    -------
    null_values: dictionary of null values by variable name
    format_strings: dictionary of formats by variable for dfn
    """
    
    null_values = {}
    format_strings = {}
    
    lost_keys = ['not_defined', 'unknown']
    
    for var in xarr.variables:
        if not 'index' in xarr[var].dims:
            continue 
        if var=='index':
            continue

        #get formats and widths
        f_l = xarr[var].attrs['format'].lower()
        
        if f_l in lost_keys:
            f_l = guess_type_precision(xarr, var)
            if f_l is None:
                print('unable to write variable %s'%var)
                continue
            

        # make a null value if it is nan or not defined 
        if (pd.isnull(xarr[var].attrs['null_value'])) or (xarr[var].attrs['null_value'] in lost_keys):
            if 'i' in f_l: #integer type
                wid = int(f_l.split('i')[1])
                null = int('-'+'9'*(wid-2))
            elif 'f' in f_l: #float type
                wid = int(f_l.split('f')[1].split('.')[0])
                decimals = int(f_l.split('f')[1].split('.')[1])
                null = float('-'+'9'*(wid-2)+'.'+'9'*(decimals))
            else: #string type
                null = 'NAN'
        else:
            null = xarr[var].attrs['null_value']

        null_values[var] = null
        format_strings[var] = f_l
            
    return null_values, format_strings

def guess_type_precision(xarr, variable, d_type=None):
    """
    Estimates the floating point or integer precision of a variable within a dataset. 

    modified from:
    https://stackoverflow.com/questions/3018758/determine-precision-and-scale-of-particular-number-in-python
    

    Parameters
    ----------
    xarr : xarray dataset
    variable : xarray variable to estimate precision of 
    d_type : force variable into this datatype and then estimate (default None)
    
    Returns
    -------
    empty string format with the precision of this variable 
    """

    
    #check for multi-dimension 
    if len(xarr.variables[variable].dims)==1:
        multi_d = ''
    elif len(xarr.variables[variable].dims)==2:
        for key in xarr.variables[variable].sizes.keys():
            if not key=='index':
                multi_d = str(xarr.variables[variable].sizes[key])
    else:
        #for 0 or higher than 2 dimensions, suggest do not write 
        return None          
    
    #data type 
    if d_type==None:
        d_type = xarr[variable].dtype
        
    #catch string objects 
    if d_type==object:
        max_len = xarr[variable].astype(str).str.len().max().values
        return 'A%s'%str(max_len+1)

    #get precision of min and max values and take the largest of the two. 
    #It is possible that more precise values exist outside of these extremes. 
    #Additional cases could be accounted for. 
    #get precision of max 
    max_x = xarr[variable].max()
    x = float(max_x)
    max_precision = sys.float_info.dig
    int_part = int(abs(x))
    max_magnitude = 1 if int_part == 0 else int(math.log10(int_part)) + 1

    frac_part = abs(x) - int_part
    multiplier = 10 ** (max_precision - max_magnitude)
    frac_digits = multiplier + int(multiplier * frac_part + 0.5)
    while frac_digits % 10 == 0:
        frac_digits /= 10
    max_scale = int(math.log10(frac_digits))
    
    #get precision of min 
    min_x = xarr[variable].min()
    x = float(min_x)
    min_precision = sys.float_info.dig
    int_part = int(abs(x))
    min_magnitude = 1 if int_part == 0 else int(math.log10(int_part)) + 1

    frac_part = abs(x) - int_part
    multiplier = 10 ** (max_precision - min_magnitude)
    frac_digits = multiplier + int(multiplier * frac_part + 0.5)
    while frac_digits % 10 == 0:
        frac_digits /= 10
    min_scale = int(math.log10(frac_digits))
    
    #make string. add a value for padding 
    if d_type==float:
        d = 'f%s.%s'%(max(max_magnitude, min_magnitude)+1, max(max_scale, min_scale)+1)
    elif d_type==int:
        d = 'i%s'%max(max_magnitude, min_magnitude)+1
    else:
        return None
    
    format = '%s%s'%(multi_d,d)

    return format

def write_dfn(*args, comments_len=80):
    xarr = args[0]
    file_out = args[1]
    null_values = args[2] 
    format_strings = args[3] 
    
    all_vars = list(null_values.keys())
    for var in all_vars:
        long_name = xarr[var].attrs.get('long_name', var)
        units = xarr[var].attrs.get('units', 'unknown')
        null_value = null_values[var]

        comments = ''
        if not units in ['unknown','']:
            comments = comments + 'UNIT=%s:'%units
        if not null_value in ['nan','']:
            comments = comments + 'NULL=%s,'%null_value
        comments = comments + 'NAME=%s'%long_name
        if len(comments)>comments_len:
            comments_len=len(comments)
    
    #write file now 
    with open(file_out, 'w+') as outfile:
        leader = 'DEFN    ST=RECD,RT=COMM;RT:A4;'
        comments = 'COMMENTS:A%s'%str(comments_len)
        newline = leader + "{:<{}}".format(comments,comments_len)
        outfile.write("{:<{}}\n".format(newline,len(newline)))

        if len(all_vars) > 99:
            base = 'DEFN{:>4} ST=RECD,RT=;'
        else:
            base = 'DEFN{:>3} ST=RECD,RT=;'
        count=0
        for var in all_vars:
            leader = base.format(count)
            chan = var
            fmt = format_strings[var]
            long_name = xarr[var].attrs.get('long_name', var)
            units = xarr[var].attrs.get('units', 'unknown')
            null_value = null_values[var]
            
            leader = leader + '%s:%s:'%(chan, fmt)
            
            comments = ''
            if not units in ['unknown','']:
                comments = comments + 'UNIT=%s:'%units
            if not null_value in ['nan','']:
                comments = comments + 'NULL=%s,'%null_value
            comments = comments + 'NAME=%s'%long_name
            if len(comments)>comments_len:
                outfile.close()
                self.write_dfn(*args, comments_len=len(comments))
                return
            
            newline = leader + "{:<{}}".format(comments,comments_len)
            outfile.write("{:<{}}\n".format(newline,len(newline)))
            count=count+1            
        outfile.write(base.format(count) + 'END DEFN\n')
    
def unreconcile_attrs(attrs_in, val):
    add_me = '[{}]'.format(val)
    
    if 'standard_name' in attrs_in.keys():
        if not add_me in attrs_in['standard_name']:
            attrs_in['standard_name'] = attrs_in['standard_name'] + add_me
            
    if 'long_name' in attrs_in.keys():
        if not add_me in attrs_in['long_name']:
            attrs_in['long_name'] = attrs_in['long_name'] + ' ' + add_me
            
    if 'format' in attrs_in.keys():
        if not attrs_in['format'] in ['not_defined', 'unknown']:
            try:
                int(attrs_in['format'][1])
                new_form = ''.join(re.findall(r'\d+|\D+', attrs_in['format'])[1:])
                attrs_in['format'] = new_form
            except ValueError:
                pass
                
    
    return attrs_in

def unreconcile_xarray(xarr_in):

    xarr = xarr_in.copy(deep=True)
    
    main_index = 'index'
    
    for var in xarr.variables:
        if main_index in xarr[var].dims:
            if len(xarr[var].dims)>1:
                other_dims = [i for i in xarr[var].dims if i !=main_index]
                
                if len(other_dims)>1:
                    raise Exception('too high of dimensions!')
                
                dim = other_dims[0]

                for i in range(xarr[var].sizes[dim]):

                    subset = xarr[var].sel(**{dim:xarr[var][dim][i]})
                    
                    new_name = var+'[{}]'.format(i)
                    xarr[new_name] = subset 
                    
                    xarr[new_name].attrs = unreconcile_attrs(xarr[new_name].attrs, i)
                    

                xarr = xarr.drop_vars(var)

        else:
            xarr = xarr.drop_vars(var)
        
    return xarr
